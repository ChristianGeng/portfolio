function adjampsapc(inpath,outpath,triallist,sensorlist,cofffile,rawpath)
% ADJAMPSAPC Adjust amplitudes using prediction of residue from all amplitudes (or principal component analysis of amplitudes)
% function adjampsapc(inpath,outpath,triallist,sensorlist,cofffile,rawpath)
% adjampsapc: Version 05.04.2013
%
%   Description
%		inpath/outpath: 
%			Amps subdirectories, specified without final pathchar
%
%       rawpath: optional. Needed if adjusted amps are to be processed by
%           calcpos. Specify without final pathchar
%       (Note: outpath and rawpath are created if necessary)
%
%       sensorlist: 
%			Vector of sensors to process.
%
%		cofffile:
%			Results of regression analysis to be used are loaded from cofffile
%			This will normally have been generated by AMPVSPOSAMPA7PC.
%
%		Background information on the contents of cofffile:
%       This must contain the cell array bc with the vector of regression
%       coefficients
%       The precise number of regression coefficients will depend on
%       whether the regression was based on the raw amplitude data, or on
%       principal components, and on the way the regression matrix was
%       constructed (e.g 'linear','interaction' : this information is
%       stored in the variable x2fx_mode. This variable must be present in
%       cofffile, i.e no defaults)
%       cofffile must also contain the cell array pc, containing as a structure for each sensor the details of
%       any principal component analysis. If field pcorder == 0 then no
%       further use is made of it.
%       (cofffile must also contain variable ampfac (premultiplication
%       factor so amplitudes are expressed (roughly) in AD units rather
%       than as normalized by the calibration): normal value 2500
%
%   See Also
%       AMPVSPOSAMPA7PC
%
%	Updates
%		2.09 Tidied up help text
%       4.2013 optional output of rawamps (for use with AG501 calcpos)

functionname='adjampsapc: Version 05.04.2013';

myversion=version;
saveop='-v6';
if myversion(1)<'7' saveop=''; end;

ampext='.amp';      %for raw amp output

doraw=0;
if nargin>5
    if ~isempty(rawpath) doraw=1; end;
end;

mkdir(outpath);
if doraw mkdir(rawpath); end;




bc=mymatin(cofffile,'bc');
x2fx_mode=mymatin(cofffile,'x2fx_mode');
pc=mymatin(cofffile,'pc');
ampfac=mymatin(cofffile,'ampfac');

newcomment=['Input path: ' inpath crlf 'Output path: ' outpath crlf ...
        'Coefficient file : ' cofffile crlf 'x2fx mode : ' x2fx_mode crlf ...
        'First/last/n trials: ' int2str([triallist(1) triallist(end) length(triallist)]) crlf ...
        'Sensor list: ' int2str(sensorlist) crlf ...
        'Adjustment coefficients in private.adjamps' crlf 'Matlab version : ' myversion crlf];


nsensor=length(sensorlist);

ndig=4;



for itrial=triallist
    inname=[inpath pathchar int2str0(itrial,ndig)];
    outname=[outpath pathchar int2str0(itrial,ndig)];
    matin=0;
    private=[];
    comment='';
    if exist([inname '.mat'])
        matin=1;
        copyfile([inname '.mat'],[outname '.mat']);
        warning off;
        private=mymatin(inname,'private');
        warning on;
        
        comment=mymatin(inname,'comment');
        
    end;
    
    %embed trace of any previous processing
    if isfield(private','adjampsapc')
        private.adjampsapc.adjampsapc=private.adjampsapc;
    end;
    
    private.adjampsapc.b=bc;
    private.adjampsapc.pc=pc;
    
    comment=[newcomment comment];
    comment=framecomment(comment,functionname);
    
    [data,SA]=loadamp(inname);
    data=data*ampfac;
    disp(itrial);
    if ~isempty(data)
        ndim=size(data,2);
        nchan=size(data,3); %only needed for info file for raw output
        for isensor=1:nsensor
            mysensor=sensorlist(isensor);
            %essential to use a copy as original data is overwritten!!
            da=data(:,:,mysensor);
            predmat=x2fx(da,x2fx_mode);
            PC=pc{mysensor};
            nscore=PC.pcorder;
            if nscore
                sduse=PC.sdev;
                if PC.covflag
                    sduse=[];
                end;
                eigvec=PC.eigvec;
                eigvec=eigvec(:,1:nscore);
                pcscore=pcscores(da,eigvec,PC.xbar,sduse);
                predmat=x2fx(pcscore,x2fx_mode);
            end;
            
            
            for idim=1:ndim
                dd=da(:,idim);
                predres=predmat*bc{mysensor,idim};
                dd=dd+predres;
                data(:,idim,mysensor)=dd;
            end;
        end;
        
        %always output as mat file, but some variables will be missing if
        %input was not mat
        data=data/ampfac;
        data=single(data);
        if matin
            save(outname,'data','comment','private','-append',saveop);
        else
            save(outname,'data','comment','private',saveop);
        end;
        
        
        %    saveamp([outpath pathchar int2str0(itrial,ndig) ampext],data);
if doraw
    %9.2012. once AG501 header format has stabilized it may be possible to
%include further information, which could be transferred in turn to the pos
%file by calcpos
            SO.samplerate=SA.samplerate;
			rawampout=[rawpath pathchar int2str0(itrial,ndig) ampext];
			saveamp3(rawampout,data,SO);
end;

        
        
    else
        disp('skipping trial');
    end;
    
end;

if doraw
    ntrans=ndim;
    sensornames=SA.dimension.axis{3};   %only works with mat input
    samplerate=SA.samplerate;
    save([rawpath pathchar 'info'],'sensornames','samplerate','comment','ntrans','nchan','private');
end;
