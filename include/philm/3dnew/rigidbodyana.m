function rigidbodyana(inpath,outpath,triallist,fixed_trafo,refobj,refsensors,rigidbodyname,methodSpec);
% RIGIDBODYANA Head normalization for AG500 data
% function rigidbodyana(inpath,outpath,triallist,fixed_trafo,refobj,refsensors,rigidbodyname,methodSpec);
% rigidbodyana: Version 23.05.2012
%
%	Syntax
%		triallist
%			vector of trial numbers
%
%		inpath
%			path to input data (i.e name without trial number)
%
%		outpath
%			path plus common part of filename. Path must be created beforehand!!
%           files with processed coordinates will be stored, as well as
%           files with rigidbody parameters if rigidbodyname is defined
%
%		fixed_trafo
%			mat file containing transformation matrix to apply to all samples
%           must be in private.hmat
%			Can be combined with refobj (see below) to define an anatomical normalization preceeding the head correction
%           Set to empty if refobj required but not fixed_trafo
%
%		refobj
%           Optional
%			mat file defining a reference object for use in e.g head movement correction
%			fixed_trafo and refobj are intended to be set up by MAKEREFOBJ
%			The two files have the same structure but are used in different ways;
%			in fact, one useful case is to use the same file for both the fixed transformation and the
%			reference object. Since the fixed transformation is carried out before samplewise mapping to the
%			reference object, this means that the rigid body parameters extracted when performing this mapping
%			can be related to an anatomically or functionally well-defined position of the reference object.
%
%		refsensors
%			Optional. Can be used to specify that only a subset of the sensors in refobj should be
%			used for head correction. If absent, all sensors are used.
%			Note in particular that sensor orientation information is referred to as a virtual sensor with
%			'v_' prefixed to the sensor name. In short, refsensors must specify a subset of the sensors and
%			virtual sensors given in the reference object file generated by MAKEREFOBJ.
%           ?? usage for jaw rigid body analysis??
%
%		rigidbodyname
%			Optional. If present, rigid body parameters are stored in new
%			mat files. 'rigidbodyname' is used as infix in the file name,
%			as well as prefix for the parameters in the file:
%			tx, ty, tz for the translations and rz, ry, rx for the rotations (about the z, y and x axes respectively).
%			If the rigid body movement is of no further interest then these parameters are strictly speaking superfluous.
%			(But they may be worth inspecting if there is suspicion of unusual features in the data).
%			If the rigid body movement is of interest, then using these parameters will generally be more effective
%			than using the raw coordinates of the original reference sensors.
%			In addition to the 6 rigid body parameters a measure of the accuracy of the reference object mapping
%			is stored in parameter 'taxdist' (short for 'average taxonomic distance'). Ideally, the reference sensors
%			can be mapped at every sample instant precisely onto the reference object. In practice, some distortion will
%			always remain; 'taxdist' is a measure of this, averaged over the reference sensors. For samples with unusually high values
%			the head-corrected movement data may not be reliable.
%
%			The taxonomic distance should be a particularly useful summary measure indicating the reliability of the
%			data. It is a kind of multidimensional counterpart to the stability of the distance between the two
%			reference sensors in the 2D system, which proved a very useful quality-control measure for the old system
%			since obviously this distance should remain constant over all trials.
% 
%       methodSpec
%           Choice of registration algorithm (can be omitted)
%`          If non-empty, must be one of Procrustes, Horn or 3-point. 
%           Three-point algorithm currently only experimental, so do not
%           use unless you know what you are doing.
%           See rege_h for more details on special cases.
%
%   Updates
%       03.2012 methodSpec introduced. See rege_h and rota_ini for more
%       details
%
%   See Also
%       MAKEREFOBJN Set up reference object for use by rigidbodyana
%



functionname='rigidbodyana: Version 28.05.2012';


method='Procrustes';
if (nargin>7)
    method=methodSpec;
end


%5.2012 determined from first file below
%nsensor=12; %fixed, or get from typical file?

comment=['Input data path: ' inpath crlf];
%comment=[comment 'Result mat name: ' resultmatname crlf];
comment=[comment 'First, last, total trials converted: ' int2str([triallist(1) triallist(end) length(triallist)]) crlf];

ndigin=4;                           %fixed????
ndigout=ndigin;

%get units of input data for position coordinates
%first file in triallist must exist
%assume units for position data are in the first element of unit (should
%use descriptor to be sure)

myfile=[inpath int2str0(triallist(1),ndigin)];
[dodo,descriptor,unit,dimension,sensorlist]=loadpos_sph2cartm(myfile);
nsensor=size(dodo,3);

outputunits=deblank(unit(1,:));
S=desc2struct(sensorlist);

%load fixed transformation

hmat_fixed=[];
if nargin>3
    if ~isempty(fixed_trafo)
        htmp=mymatin(fixed_trafo,'private');
        if ~isempty(htmp)

            hmat_fixed=htmp.hmat;
            comment=[comment 'Fixed transformation input file: ' fixed_trafo crlf];
            commentf=mymatin(fixed_trafo,'comment','<No comment for fixed transformation>');
            %document
            dataf=mymatin(fixed_trafo,'data');
            labelf=mymatin(fixed_trafo,'label');
            unitf=mymatin(fixed_trafo,'unit');

            if ~strcmp(deblank(unitf(1,:)),outputunits)
                %maybe try and repair automatically??
                error(['Translation in fixed transformation must be in ' outputunits]);
            end;


            comment=[comment 'Comment for fixed transformation' crlf commentf crlf];
            comment=[comment 'Reference object from fixed transformation' crlf];

            fixed_trafoS.hmat=hmat_fixed;
            fixed_trafoS.data=dataf;
            fixed_trafoS.label=labelf;
            fixed_trafoS.unit=unitf;



            comment=[comment 'Translations (tx, ty, tz) in ' outputunits ' and rotations (rz, ry, rx) in deg. from fixed transformation' crlf];
            hhh=showth(hmat_fixed);
            comment=[comment 'T: ' num2str(hhh(1:3)) ' R: ' num2str(hhh(4:6)*180/pi) crlf];

        end;
    end;
end;




%maybe better taken as comment from refobj file???
%    comment=[comment 'X/Y/Z is in terms of skull coordinates' crlf];
%    comment=[comment 'X=Lateral (increase to left)' crlf  'Y = Anterior-posterior (increase from front to back)' crlf 'Z = Longitudinal (increase from foot to head)' crlf];

%Normally this will be roughly like rotating the autokal coordinate
%system 90 degrees in the xy plane

%load and sort out reference object

%check for refobj input. if missing or empty only do fixed trafo

nrefs=0;

samefile=0;


if nargin>4

    if not(isempty(hmat_fixed))
        samefile=strcmp(fixed_trafo,refobj);
    end;

    dataref=mymatin(refobj,'data');
    labelref=mymatin(refobj,'label');
    unitref=mymatin(refobj,'unit');
    if ~strcmp(deblank(unitref(1,:)),outputunits)
        %maybe try and repair automatically??
        error(['Translation in reference object transformation must be in ' outputunits]);
    end;
    rprivate=mymatin(refobj,'private');
    vdistance=rprivate.vdistance;
    hmat_ref=rprivate.hmat;

    if nargin<6 refsensors=labelref; end;
    if isempty(refsensors) refsensors=labelref; end;

    oneref=0;
    if size(refsensors,1)==1
        oneref=1;
    end;

    if oneref
        disp('Head correction with translation only');
    end;



    nrefs=size(refsensors,1);

    vprefix='v_';

    refsensindex=zeros(1,nrefs);
    refvflag=zeros(1,nrefs);
    datarefuse=zeros(nrefs,size(dataref,2));

    for ii=1:nrefs
        tmps=deblank(refsensors(ii,:));
        vv=strmatch(tmps,labelref);
        if length(vv)~=1
            disp(refsensors);
            disp(labelref);
            error('refsensor not in refobj');
        end;

        datarefuse(ii,:)=dataref(vv,:);
        vv=findstr(vprefix,tmps);
        if ~isempty(strmatch(vprefix,tmps)) refvflag(ii)=1; end;
        tmps=strrep(tmps,vprefix,'');
        refsensindex(ii)=getfield(S,tmps);
    end;

    comment=[comment 'Reference object input file: ' refobj crlf];

    if not(samefile)
        commentr=mymatin(refobj,'comment','<No comment for reference object>');
        %document

        comment=[comment 'Comment for reference object' crlf commentr crlf];

    end;

    refobjS.hmat=hmat_ref;
    refobjS.data=dataref;
    refobjS.label=labelref;
    refobjS.unit=unitref;


    if not(samefile)

        comment=[comment 'Translations (tx, ty, tz) in ' outputunits ' and rotations (rz, ry, rx) in deg. from reference object transformation' crlf];
        hhh=showth(hmat_ref);
        comment=[comment 'T: ' num2str(hhh(1:3)) ' R: ' num2str(hhh(4:6)*180/pi) crlf];
    end;

    comment=[comment 'Sensors used in transformation:' crlf strm2rv(refsensors,' ') crlf];
    methodstr=method;
    if ~ischar(method) methodstr=int2str(method); end;
    comment=[comment 'Method used for computing transformation: '  methodstr crlf];

end;

%prepare for rigid body parameter output

%get outputunits from refobj file???

rigname='';
if nargin>6 rigname=rigidbodyname; end;

descrig=str2mat('tx','ty','tz','rz','ry','rx');
unitrig=str2mat(outputunits,outputunits,outputunits,'deg','deg','deg');
rigrotfac=180/pi;
descrig=strcat([rigname '_'],descrig);
descrig=str2mat(descrig,'taxdist');
unitrig=str2mat(unitrig,outputunits);



%needed????
comment=[comment 'Sensor orientation is given by the x, y and z coordinates' crlf];
comment=[comment 'of a unit-length vector relative to the sensor position' crlf];


basecomment=comment;


%accumulate statistics on the reference object registration
ntrial=max(triallist);
badreg=ones(ntrial,1)*NaN;
taxx=ones(ntrial,1)*NaN;
taxsd=ones(ntrial,1)*NaN;
taxnansum=ones(ntrial,1)*NaN;

nancountbuf=ones(ntrial,nsensor)*NaN;

rigoutx=ones(ntrial,6)*NaN;
rigoutsd=ones(ntrial,6)*NaN;

%===================================================
%main loop, thru trials
%===================================================

for itrial=triallist
    itrialout=itrial;
    trials=int2str0(itrial,ndigin);
    rawpath=[inpath trials];
%keyboard;
    nd=0;
    if exist([rawpath '.mat'],'file')
        trialso=int2str0(itrial,ndigout);
%        disp(rawpath);
%        disp([outpath trialso]);
        [copySUCCESS,copyMESSAGE,copyMESSAGEID]=copyfile([rawpath '.mat'],[outpath trialso '.mat']);
        if ~copySUCCESS
            disp(['Unable to copy from ' rawpath ' to ' outpath]);
            disp(copyMESSAGE);
            disp('Hint: Make sure output path has been created');
            return;
        end;
        
        disp(['Loading trial ' trials ' ...']);


        [bigbuf,descriptor,unit,dimension,tmplist]=loadpos_sph2cartm(rawpath);
        nd=size(bigbuf,1);

        comment=mymatin(rawpath,'comment','<No comment in input signal file>');
        private=mymatin(rawpath,'private');

        if not(isempty(hmat_fixed)) private.fixed_trafo=fixed_trafoS; end;
        if nrefs private.refobj=refobjS; end;



        Pout=desc2struct(descriptor);

        if ~nd disp('Input file empty or missing; skipping this trial'); end;
    end;


    if nd



        %quick check for NaNs
        %assume checking one coordinate is sufficient
        nancount=sum(isnan(squeeze(bigbuf(:,Pout.posx,:))));
        if any(nancount)
        disp(['NaNs per sensor in input: ' int2str(nancount)]);
        end;
        nancountbuf(itrialout,:)=nancount;


        %additional check for NaNs in the reference sensors
        %since this will result in the result for all sensors being NaNs



        if ~isempty(hmat_fixed)
            disp('Performing fixed transformation');
            bigbuf=rotor(bigbuf,Pout,hmat_fixed);
        end;



        %================
        %sample by sample mapping to reference object
        %=================


        %precompute rotations for all sample points

        if nrefs
            if oneref
                disp('Doing head correction, translation only');
                ppp=[Pout.posx Pout.posy Pout.posz];
                ref1d=bigbuf(:,ppp,refsensindex(1));
                ns=size(bigbuf,3);
                for i1=1:ns
                    bigbuf(:,ppp,i1)=bigbuf(:,ppp,i1)-ref1d;
                end;

                nd=size(bigbuf,1);
                %needed for output
                taxdist=ones(nd,1)*NaN;
                rigout=ones(nd,6)*NaN;

                %does sign corrspond to usage for normal case?
                rigout(:,1:3)=ref1d;



            else

                disp('Computing transformation to reference object');

                % keyboard;
                [rotmatb,rotmatbi,taxdist]=getregemat(bigbuf,Pout,datarefuse,refsensindex,refvflag,vdistance,method);
                
                vbadreg=find(taxdist==-1);
                nbadreg=length(vbadreg);
                if nbadreg
                    %keyboard
                    taxdist(vbadreg)=NaN;
                    disp(['n unreliable registration : ' int2str(nbadreg)]);
                end;

                %rather than defining the head-movement compensation the transformation can
                % also be seen as providing the rigid body parameters of head movement

                %display statistics of taxonomic distance as a measure of the reliability of the reference sensors
                badreg(itrialout)=nbadreg;

                taxx(itrialout)=nanmean(taxdist);
                taxsd(itrialout)=nanstd(taxdist);
                taxnansum(itrialout)=sum(isnan(taxdist));

                sss=['Trial ' trials '. Taxonomic distance mean/sd/nansum : ' num2str([taxx(itrialout) taxsd(itrialout)]) ' ' int2str(taxnansum(itrialout))];
                disp(underl(sss));
                disp(sss);
                disp(underl(sss));

                %		also collect statistics of the rigid body parameters

                %output the transformation from ref object to data as the rigid
                %body parameters (see notes on getregemat)
                rigout=showth(rotmatbi);
                rigout(:,4:6)=rigout(:,4:6)*rigrotfac;
                rigoutx(itrialout,:)=nanmean(rigout);
                rigoutsd(itrialout,:)=nanstd(rigout);

                disp(['Rigid body means: ' num2str(rigoutx(itrialout,:))]);
                disp(['Rigid body sds  : ' num2str(rigoutsd(itrialout,:))]);

                disp('Performing transformation to reference object (head mode)');
                bigbuf=rotorm(bigbuf,Pout,rotmatb);
                %            keyboard;
            end;        %only one ref sensor
        end;            %nrefs



        disp('transformation complete');




        data=bigbuf;

        comment=[basecomment crlf comment];
        comment=framecomment(comment,functionname);


        % keyboard
        %Output: In addition to data, append other changed variables
        save([outpath trialso],'data','descriptor','unit','dimension','comment','private','-append');


        if not(isempty(rigname))
            data=[rigout taxdist];
            descriptor=descrig;
            unit=unitrig;
            %any other variables from input data file??
            %everything except dimension??
            samplerate=mymatin(rawpath,'samplerate');
%usually not present
            warning off;
            t0=mymatin(rawpath,'t0',0);
warning on;
            item_id=mymatin(rawpath,'item_id');
            save([outpath rigname '_' trialso],'data','descriptor','unit','samplerate','comment','private','t0','item_id');

        end;


    end;		%nd > 0
end;		%trial loop


%display total nans

hfn=figure;
hlnan=plot(nancountbuf,'linewidth',2);
[hlegn,hlobj]=legend(hlnan,sensorlist);
title('Total missing data per trial');
hxx=findobj(hlobj,'type','text');
set(hxx,'interpreter','none');

%display and store figs of taxonomic distances

if nrefs
    hftx=figure;
    plot(taxx,'linewidth',2);
    title('Average taxonomic distance per trial');
    ylabel(outputunits);
    xlabel('Trial');
    hftsd=figure;
    plot(taxsd,'linewidth',2);
    title('SD of taxonomic distance per trial');
    ylabel(outputunits);
    xlabel('Trial');
    hftnans=figure;
    plot(taxnansum,'linewidth',2);
    title('Reference object registration: Total missing samples per trial');

    hfrxt=figure;
    hlrxt=plot(rigoutx(:,1:3));
    ylabel(outputunits);
    haltmp=legend(hlrxt,descrig(1:3,:));
    title('Rigid body translation: Means per trial');

    hfrsdt=figure;
    hlrsdt=plot(rigoutsd(:,1:3));
    ylabel(outputunits);
    haltmp=legend(hlrsdt,descrig(1:3,:));
    title('Rigid body translation: SDs per trial');

    hfrxr=figure;
    hlrxr=plot(rigoutx(:,4:6));
    ylabel(unitrig(4,:));
    haltmp=legend(hlrxr,descrig(4:6,:));
    title('Rigid body rotation: Means per trial');

    hfrsdr=figure;
    hlrsdr=plot(rigoutsd(:,4:6));
    ylabel(unitrig(4,:));
    haltmp=legend(hlrsdr,descrig(4:6,:));
    title('Rigid body rotation: SDs per trial');

    save([outpath '_stats'],'nancountbuf','taxx','taxsd','taxnansum','rigoutx','rigoutsd','descrig','unitrig','badreg');

end;

htx=findobj('type','text');
set(htx,'interpreter','none');

%disp(['Finished rigid body analysis using ' method ' method ...'])
keyboard;



%do inverse for autokal to tapad?????
function AT=t2a
%transformation matrix from tapad to autokal
%9.02 converted to homogeneous matrix with zero translation

AT = [ -5.7735026962962970e-001  5.7735026962962970e-001 -5.7735026962962970e-001;...
    -7.0710678222222210e-001 -7.0710678222222210e-001  0.0000000000000000e+000;...
    -4.0824829037037030e-001  4.0824829037037030e-001  8.1649658074074060e-001];

AT=[[AT zeros(3,1)];[0 0 0 1]];


function bufout=rotor(bufin,P,rotmat)
%applies same transformation to all samples of all channels
%rotmat must be a homogeneous matrix specifying rotation and translation and
% must be designed for use as M*v where v is a column matrix of coordinates
% thus we have to fiddle around with transpostion here

bufout=bufin;
ns=size(bufin,3);	%number of sensors
nd=size(bufin,1);	%number of data
rotonly=rotmat(1:3,1:3);


for ii=1:ns
    tmp=([bufin(:,[P.posx P.posy P.posz],ii) ones(nd,1)])';
    tmp=(rotmat*tmp)';
    bufout(:,[P.posx P.posy P.posz],ii)=tmp(:,1:3);
    %orientations are only rotated, not translated
    bufout(:,[P.orix P.oriy P.oriz],ii)=(rotonly*(bufin(:,[P.orix P.oriy P.oriz],ii))')';
end;


function bufout=rotorm(bufin,P,rotmatb);
% basically same as rotor (see above) but
% does all samples for multiple channels; separate rotation for each sample
%

%keyboard
ns=size(bufin,3);	%number of sensors
nd=size(bufin,1);	%number of data
bufout=bufin;

for isamp=1:nd
    rotmat=rotmatb(:,:,isamp);
    rotonly=rotmat(1:3,1:3);
    tmp=[squeeze(bufin(isamp,[P.posx P.posy P.posz],:));ones(1,ns)];
    %   disp('1');keyboard;
    tmp=rotmat*tmp;
    %   disp('2');keyboard;
    bufout(isamp,[P.posx P.posy P.posz],:)=tmp(1:3,:);
    %   disp('3');keyboard;

    tmp=squeeze(bufin(isamp,[P.orix P.oriy P.oriz],:));
    tmp=rotonly*tmp;
    bufout(isamp,[P.orix P.oriy P.oriz],:)=tmp;
end;

function [rotmatb,rotmatbi,taxdist]=getregemat(bigbuf,P,datarefuse,refsensindex,refvflag,vdistance,methodSpec);
%get transformation matrices to map data samplewise to reference object (in
%rotmapb
%rotmapbi contains the mapping from the reference object to the data
% use this as e.g head movement components
%Not clear why the translations and rotations derived from rotmapbi are not
%identical to the negative of those from rotmapb.
% They are usually pretty close, but by no means the same.
% (maybe only identical when taxonomic distance is zero)

%get cartesian coordinates for all sensors, whether virtual or not

method='Procrustes';
if (nargin>6)
    method=methodSpec;
end
    if ischar(method) disp(['using ' method ' method ...']); end;

tmpd=bigbuf(:,[P.posx P.posy P.posz],refsensindex);
nref=length(refsensindex);
%convert orientation information to virtual sensor
for ii=1:nref
    if refvflag(ii)
        tmpo=bigbuf(:,[P.orix P.oriy P.oriz],refsensindex(ii));
        tmpd(:,:,ii)=tmpd(:,:,ii)+(tmpo*vdistance);
    end;
end;

%rearrange for use by rege_h, i.e sensors*coordinates*time

tmpd=permute(tmpd,[3 2 1]);

[rotmatb,taxdist]=rege_h(datarefuse,tmpd,method);


%keyboard;

%temporary: test reverse direction
rotmatbi=ones(size(rotmatb))*NaN;
taxdisti=ones(size(taxdist))*NaN;
disp('reversing rigid body transformation')
for ii=1:size(rotmatb,3)
    [rotmatbi(:,:,ii),taxdisti(ii)]=rege_h(tmpd(:,:,ii),datarefuse,method);
end;

%keyboard;

function hmati=invrotmat(hmat);
%reverse the direction of the transformation

hmati=hmat;
np=1;
if ndims(hmat)>2 np=size(hmat,3); end;

for ii=1:np
    tmp=hmat(1:3,1:3,ii);
    hmati(1:3,1:3,ii)=tmp';
    hmati(1:3,4)=-hmat(1:3,4);
end;
